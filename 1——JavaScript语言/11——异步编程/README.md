ECMAScript 6 及之后的几个版本逐步加大了对异步编程机制的支持:

- ECMAScript 6 新增了正式的 Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。
- 接下来几个版本增加了使用 async 和 await 关键字定义异步函数的机制。

# 一，异步编程

同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在 JavaScript 这种单线程事 件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。

## （一）同步与异步

同步行为对应内存中顺序执行的处理器指令，这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。

> [1——同步程序.js](1——JavaScript语言/11——异步编程/程序文件/1——同步程序.js)

异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。

- 异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。
  如果代码要访问 一些高延迟的资源，那么就会出现长时间的等待。
- 比如向远程服务器发送请求并等待响应。

> [2——异步程序.js](1——JavaScript语言/11——异步编程/程序文件/2——异步程序.js)

🌰：在定时回调中执行一次简单的数学计算：

```JavaScript
let x = 3; 
setTimeout(() => x = x + 4, 1000);
```

但这一次执行线程不知道 x 值何时会改变，因为这取决于回调何时从消息队列出列并执行。

- 回调操作是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对 JavaScript 运行时来说是一个黑盒。

设计一个能够知道 x 什么时候可以读取的系统是非常难的。JavaScript 在实现这样一个系统的过程 中也经历了几次迭代。



## （二）以往的异步编程模式

异步行为是 JavaScript 的基础，但以前的实现不理想。

在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。

- 串联多个异步操作是一个常见的需求，结果就是深度嵌套多层回调函数，但会造成**回调地狱**问题。

🌰：一个异步函数：使用 `setTimeout` 在一秒钟之后执行某些操作

```JavaScript
function double(value) { 
	setTimeout(
		() => setTimeout(console.log, 0, value * 2) ,
		1000
	); 
} 

double(3); // 6（大约 1000 毫秒之后）
```

**这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数！**
1，首先是`setTimeout` 可以接收一个在指定时间之后会被调度执行的回调函数。
2，然后 JavaScript 运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 JavaScript 代码就完全不可见了。
3，double() 函数在 `setTimeout` 成功调度异步操作之后会立即退出。

### 1，异步返回值

假设 setTimeout 操作会返回一个有用的值，有什么好办法把这个值传给需要它的地方？

广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。

> [3——以往的异步编程模式：返回异步值](1——JavaScript语言/11——异步编程/程序文件/3——以往的异步编程模式：返回异步值.js)
>


# 二，Promise

# 三，异步函数

## （一）

## （二）

## （三）

## （四）

# 四，

# 五，

# 六，

# 七，

# 八，

# 九，

# 十，

# 十一，

## （一）

## （二）

## （三）

## （四）

## （五）

## （六）

## （七）

## （八）

## （九）

## （十）

## （十一）

### 1，

### 2，

### 3，

### 4，

### 5，

### 6，

### 7，

### 8，

#### （1）

#### （2）

#### （3）

#### （4）

#### （5）

#### （6）

#### （7）

#### （8）
